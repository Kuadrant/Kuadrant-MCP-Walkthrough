# Project: Request Body-Based Routing Experimentation Environment

## Project Overview
This is an experimentation environment for request body-based routing using Envoy proxy with custom filters. The system consists of:
- **Envoy Proxy**: Main ingress point with custom filter configuration
- **Ext-Proc Filter**: Go-based external processing filter that parses request bodies and adds routing headers
- **Debug WASM Filter**: Rust-based WebAssembly filter for logging and debugging
- **Echo Servers**: Simple HTTP echo servers for testing routing
- **Docker Compose**: Local development environment orchestration

## Architecture
```
Client Request → Envoy → Ext-Proc Filter → Debug WASM Filter → Echo Server 1/2
                   ↓         ↓                     ↓
               Parse Body → Add Headers → Log Processing → Route Decision
```

## Key Directories & Files
- `ext-proc/cmd/bbr/main.go`: Main entry point for the ext-proc filter
- `ext-proc/pkg/bbr/`: Core Go logic for body-based routing
- `src/lib.rs`: Rust debug WASM filter implementation
- `envoy.yaml`: Envoy proxy configuration
- `docker-compose.yaml`: Local development environment
- `ext-proc/`: Extended processing filter logic and APIs

## Technology Stack
- **Go**: Ext-proc filter implementation
- **Rust**: Debug WASM filter implementation
- **Envoy Proxy**: HTTP proxy and load balancer
- **Docker**: Containerization and local development
- **HTTP Echo Servers**: Simple test backends

## Coding Standards

### Go Code (Ext-Proc Filter)
- Follow standard Go conventions and `go fmt`
- Use structured logging with context
- Implement proper error handling with wrapped errors
- Use dependency injection for testability
- Follow the existing package structure under `pkg/bbr/`
- Write unit tests for all business logic
- Use meaningful variable names that reflect the domain (e.g., `requestBody`, `routingHeader`)

### Rust Code (Debug WASM Filter)
- Follow Rust conventions and use `rustfmt`
- Use the `proxy_wasm` crate for Envoy integration
- Keep WASM module minimal and focused on debugging/logging
- Use structured logging with `[WASM]` prefix for clarity
- Minimize dependencies and code complexity

### Configuration Files
- Use YAML for configuration (Envoy, Docker Compose)
- Include comments explaining complex routing rules
- Keep environment-specific configurations separate
- Validate configurations before deployment

## Development Workflow
1. **Local Development**: Use `make up` to run the full stack locally
2. **Testing**: Test both individual filters and end-to-end routing behavior
3. **Debugging**: Use Envoy admin interface and structured logging for troubleshooting
4. **Iteration**: Hot-reload capabilities for rapid development cycles

## Common Tasks
- **Adding new routing rules**: Modify `envoy.yaml` and corresponding filter logic
- **Testing body parsing**: Use `test-execution-order.sh` or curl with JSON-RPC payloads
- **WASM deployment**: Build with `make build-wasm` (uses `cargo build --target wasm32-wasip1 --release`)
- **Ext-proc debugging**: Check logs and use Envoy's ext_proc statistics

## Request Body Parsing Context
- The system intercepts HTTP requests and parses JSON-RPC messages
- Routing decisions are made based on the `method` field in JSON-RPC requests
- The `x-rpc-method` header is added to facilitate upstream selection
- Simple JSON-RPC parsing without complex protocol handling

## Simple JSON-RPC Routing
- **Echo1 requests**: `method: "echo1"` → routes to echo1 server
- **Echo2 requests**: `method: "echo2"` → routes to echo2 server
- **Default requests**: Route to echo2 server
- **Method extraction**: Extracts from `method` field in JSON-RPC request body

## Debug WASM Filter
- **Purpose**: Logging and debugging execution flow
- **Functionality**: Logs each phase of request/response processing
- **Phases logged**:
  - Request header processing
  - Request body processing
  - Response header processing
  - Response body processing
- **No business logic**: Only logging, no parsing or modification

## Performance Considerations
- Minimize parsing overhead in hot paths
- Use streaming parsing for large request bodies when possible
- Keep WASM module memory usage low
- Debug delays can be added for execution order testing

## Security Notes
- Validate all input from request bodies
- Sanitize extracted values before using in headers
- Implement proper timeout handling for ext-proc calls
- Consider rate limiting and abuse prevention

## Testing Strategy
- Unit tests for parsing logic
- Integration tests with sample requests
- End-to-end tests through the full proxy chain
- Use `test-execution-order.sh` for debugging execution flow

## Deployment Considerations
- WASM filters are deployed as part of Envoy configuration
- Ext-proc filters run as separate services
- Echo servers provide simple test backends
- Monitor filter performance and error rates

## When suggesting code changes:
- Consider the impact on both Go and Rust components
- Ensure changes work with the existing Envoy configuration
- Provide examples of how to test the changes locally
- Consider backwards compatibility with existing routing rules
- Suggest appropriate logging for debugging purposes

## Common Debugging Steps:
1. Check Envoy admin interface at :9901/stats for filter metrics
2. Examine ext-proc service logs for parsing errors
3. Verify WASM module loading in Envoy logs
4. Test routing with `test-execution-order.sh` or curl commands
5. Use Envoy's request tracing for end-to-end visibility
6. Monitor execution order with debug delays when needed

## Build Commands:
- `make build-wasm`: Build the debug WASM filter
- `make up`: Start the environment with rebuilding
- `make up-fast`: Start without rebuilding
- `make down`: Stop the environment
- `make rebuild-ext-proc`: Rebuild just the ext-proc service 